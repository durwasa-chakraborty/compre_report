\section{Cosmo: A Concurrent Separation Logic for Multicore OCaml \cite{cosmo2020}}\label{sec:cosmo}


\subsection{Motivation}
So far, we have established a framework for verifying concurrent programs under
sequential consistency (SC). Under SC, the execution of a concurrent program can
be understood as an interleaving of thread-local actions over a single,
centralized shared memory, which makes reasoning about correctness comparatively
straightforward.

However, real-world programming languages, such as OCaml, do not operate under
sequential consistency. Instead, they adopt relaxed (or weak) memory models,
where program executions are not necessarily representable as simple
interleavings of thread actions. As a result, correctness reasoning must account
for the semantics of the underlying memory model before addressing higher-level
concurrent behavior.

 To reason about concurrent programs in such languages, one must first reason at
 a low level, directly in terms of the memory model and its allowed reorderings
 and visibility constraints. The terms weak memory model and relaxed memory
 model are used interchangeably, both referring to the fact that program
 execution is no longer constrained to behave as if all threads interact with a
 single, sequentially consistent memory. Instead, memory effects may be
 reordered or observed differently by different threads.

Once a framework for low-level reasoning is in place, it becomes possible to
reason modularly about libraries of concurrent data structures, and subsequently
about the high-level programs that rely on them.

Fortunately, the Multicore OCaml memory model is significantly simpler to reason
about than other managed memory models, such as the Java Memory Model (JMM). A
compelling example that corroborates this is the absence of \emph{word tearing}.
In Java, if 64-bit values (like \texttt{long} or \texttt{double}) are not
declared \texttt{volatile}, the specification allows a thread to observe a torn
read ; seeing the top 32 bits of an old value combined with the bottom 32 bits
of a new value. In contrast, OCaml values are almost universally word-sized
(represented as pointers or tagged integers). Even larger values like
\texttt{float} are typically boxed and handled as atomic pointer updates,
ensuring that word tearing is generally unobservable in OCaml. It distinguishes
between two kinds of memory locations: atomic and nonatomic. Atomic locations
come with well-defined synchronization guarantees, whereas nonatomic locations
must be accessed in a data-race-free manner to ensure sequential consistency.

Reasoning about atomic locations follows a similar spirit to the approach
discussed in earlier work on linearizability-based verification
\cite{Vafeiadis2010}. In particular, when an operation performs a stateful
change, it becomes possible to identify a clear correctness condition tied to
the update. In contrast, stateless operations require the logic to retain and
compose all relevant information to justify correctness.

Cosmo builds precisely such a framework: one that supports low-level reasoning
about relaxed memory behaviors while enabling compositional, high-level
reasoning about concurrent programs and data structures.

\subsection{Proposed Solution}



\begin{figure}[t]
\centering
\begin{align*}
a &\in \mathsf{Loc}_{\mathsf{NA}} \\ A &\in \mathsf{Loc}_{\mathsf{AT}} \\ t &\in
\mathsf{Time} \;\triangleq\; \mathbb{Q} \cap [0,\infty) \\ h &\in \mathsf{Hist}
  \;\triangleq\; \mathsf{Time} \xrightarrow{\mathit{fin}} \mathsf{Val} \\ V, W,
  G &\in \mathsf{View} \;\triangleq\; \mathsf{Loc}_{\mathsf{NA}}
  \xrightarrow{\mathit{set}} \mathsf{Time} \\ \sigma &\in \mathsf{Store}
  \;\triangleq\; (\mathsf{Loc}_{\mathsf{NA}} \xrightarrow{\mathit{fin}}
  \mathsf{Hist}) \\ &\quad \times (\mathsf{Loc}_{\mathsf{AT}}
  \xrightarrow{\mathit{fin}} (\mathsf{Val} \times \mathsf{View}))
\end{align*}
\caption{Semantic objects: locations, time stamps, histories, views, and
  stores.}
\label{fig:semantic-objects}
\end{figure}



\begin{figure}[t]
\centering
\vspace{1em}

\textsc{Mem-AT-Alloc}
\[
\frac{A \notin \mathrm{dom}\,\sigma}
     {\sigma; W \xrightarrow{\mathrm{alloc}(A,v)}
      \sigma[A \mapsto (v,W)]; W}
\]

\textsc{Mem-NA-Read}
\[
\frac{h = \sigma(a) \quad t \in \mathrm{dom}\,h \quad
      W(a) \le t \quad v = h(t)}
     {\sigma; W \xrightarrow{\mathrm{rd}(a,v)} \sigma; W}
\]

\textsc{Mem-AT-Read}
\[
\frac{\sigma(A) = (v,V)}
     {\sigma; W \xrightarrow{\mathrm{rd}(A,v)}
      \sigma; W \sqcup V}
\]

\textsc{Mem-NA-Write}
\[
\frac{h = \sigma(a) \quad t \notin \mathrm{dom}\,h \quad
      W(a) < t \quad h' = h[t \mapsto v]}
     {\sigma; W \xrightarrow{\mathrm{wr}(a,v)}
      \sigma[a \mapsto h']; W[a \mapsto t]}
\]

\textsc{Mem-AT-Write}
\[
\frac{\sigma(A) = (v,V) \quad V' = W' = W \sqcup V}
     {\sigma; W \xrightarrow{\mathrm{wr}(A,v')}
      \sigma[A \mapsto (v',V')]; W'}
\]

\textsc{Mem-AT-Read-Write}
\[
\frac{\sigma(A) = (v,V) \quad V' = W' = W \sqcup V}
     {\sigma; W \xrightarrow{\mathrm{rdwr}(A,v,v')}
      \sigma[A \mapsto (v',V')]; W'}
\]

\caption{Operational Semantics}
\label{fig:operational-semantics}
\end{figure}


Figure \ref{fig:semantic-objects} presents the core semantic objects that
explain Cosmo’s formalization of the Multicore OCaml memory model. The diagram
introduces a small collection of structured entities— locations, time stamps,
histories, views, and stores.

Memory locations are partitioned into nonatomic locations $a \in
\mathrm{Loc}_{na}$ and atomic locations $A \in \mathrm{Loc}_{at}$. Time stamps
$t \in \mathrm{Time}$ are drawn from the nonnegative rationals and are used to
order write events at nonatomic locations. A history $h \in \mathrm{Hist}$ is a
finite map from time stamps to values; it records, for a single nonatomic
location, the sequence of writes that have occurred, each represented as a
timestamp–value pair.

Views $V \in \mathrm{View}$ are total mappings from nonatomic locations to time
stamps (almost everywhere zero). Intuitively, a view represents
\emph{visibility} for each location; it records the most recent write that a
thread is aware of. Each thread carries its own current view $W$, which
constrains which writes it is allowed to observe and determines how its
knowledge evolves over time.

Finally, the store $\sigma \in \mathrm{Store}$ aggregates these components. It
consists of a nonatomic store mapping each nonatomic location to its history,
and an atomic store mapping each atomic location to a pair consisting of a value
and a view. In this way, the figure showcases how writes are created (by
extending histories), how they are ordered (via time stamps), and how visibility
is transferred (through the views associated with atomic operations). Put
plainly, the semantics explains how Cosmo keeps track of who can see what is in
the memory, and which operations only read that information versus which ones
actively share it with others.



\subsection*{BaseCosmo}

The Figure \ref{fig:operational-semantics} describes the operational semantics
of Cosmo describe how a program executes at the machine level: an expression (e)
reduces to a new expression (e'), possibly interacting with the memory subsystem
through a memory event and possibly spawning new threads. These semantics
precisely track how memory locations, histories, timestamps, and views evolve
during execution. However, while such a semantics tells us \emph{what can
happen}, it does not by itself tell us \emph{how to reason compositionally}
about programs, or how to prove that a program is safe or correct.

Cosmo instantiates Iris, a generic framework for building concurrent separation
logics. Iris provides the logical infrastructure, assertions, ghost state,
invariants, weakest preconditions, and proof rules, while BaseCosmo supplies the
Multicore OCaml–specific ingredients.


To make this precise, BaseCosmo introduces assertions such as points-to
assertions and a valid-view assertion. Points-to assertions describe ownership
and knowledge of individual memory locations, both nonatomic and atomic, while
the valid-view assertion captures the global invariant relating thread views to
the store. Atomic points-to assertions additionally account for the fact that
atomic locations store a view (V), which can later be merged into a thread’s
view (W), explicitly propagating visibility.

Hoare triples\cite{hoare-logic} are the interface through which all of this
reasoning is exposed. A triple ({P}, (e, W), {$\Phi$}) states that if the
precondition (P) holds, then executing expression (e) in a thread with view (W)
is safe, and if it terminates, it produces a value and an updated view
satisfying the postcondition ($\Phi$). Iris supplies the generic machinery for
weakest preconditions, framing, and invariants, while BaseCosmo provides the
memory-specific axioms that explain how reads, writes, allocations, and atomic
operations affect ownership and views.

To see how the operational semantics are reflected in the logic, consider the
rule \textsc{Mem-NA-Write}. Operationally, this rule states that writing a value
$v$ to a nonatomic location $a$ extends the history $h = \sigma(a)$ with a fresh
timestamp $t$ such that $W(a) < t$, producing a new history $h' = h[t \mapsto
  v]$, and updates the thread’s view to $W[a \mapsto t]$. Semantically, this
means that a write does not overwrite a location in place; rather, it creates a
new write event in the history of $a$, ordered after all writes currently
visible to the thread. The store $\sigma$ is updated to record this extended
history, while the thread’s view is advanced to reflect awareness of this newly
created event.


Let's take another example, consider the rule \textsc{Mem-AT-Write}.
Operationally, this rule describes writing a new value $v'$ to an
atomic location $A$. Suppose the atomic store contains
$\sigma(A) = (v, V)$, where $V$ is the view currently stored at $A$.
The rule updates the store to
$\sigma[A \mapsto (v', V')]$, where
\[
V' = W' = W \sqcup V.
\]
Here, $\sqcup$ denotes the join of views.

This union is indicative of the fact that atomic writes in
Multicore OCaml has both \emph{release} and \emph{acquire} effects.
Before performing the write, the thread may already have learned new
information about nonatomic locations, represented by its current
view $W$. Meanwhile, the atomic location may already carry visibility
information $V$ from previous synchronizations. By computing
$W \sqcup V$, the write ensures that both pieces of information are
preserved and propagated.

Intuitively, the atomic location acts as a visibility carrier.
Whatever the writing thread currently knows (its view $W$) is merged
with whatever knowledge was already attached to the atomic location
($V$), and the result is stored back into the location. Future threads
that read from $A$ will acquire this combined view.

A small example clarifies this propagation. Suppose thread $T_1$
performs:
\[
a :=_{\text{na}} 42;
\quad
A :=_{\text{at}} 1.
\]
The nonatomic write creates a new timestamp in the history of $a$,
and updates $T_1$’s view to record awareness of this write.
When $T_1$ subsequently writes to atomic location $A$, its current
view $W$—which now includes the write to $a$—is merged into the view
stored at $A$.

Now suppose another thread $T_2$ later performs:
\[
\texttt{!at } A.
\]
By rule \textsc{Mem-AT-Read}, $T_2$’s view becomes
\[
W_2' = W_2 \sqcup V',
\]
where $V'$ is the view stored at $A$. Since $V'$ already contains
the write to $a$, $T_2$ now becomes aware of that write—even though
$a$ itself is nonatomic.


\subsection*{A Higher Level Logic : Cosmo}

While BaseCosmo provides a faithful translation of the Multicore OCaml
operational semantics, it remains intentionally low-level. In particular, it
exposes details such as histories, timestamps, and per-thread views directly in
assertions. This precision is useful for soundness, but it makes reasoning
cumbersome: even in data-race-free code, a nonatomic location appears to store
an entire history rather than a single value, and every Hoare triple must
explicitly mention the current thread’s view (W).

On top of BaseCosmo, Cosmo offers a higher-level logic in which nonatomic
locations can again be reasoned about as if they store a single value, provided
the program is data-race free while still remaining sound with respect to
relaxed memory.

Instead of asserting a BaseCosmo proposition directly, a Cosmo assertion denotes
a function from views to BaseCosmo assertions. Subjective assertions, such as
\emph{this thread has seen view (V)}, depend on the current thread’s snapshot and
therefore cannot be shared. Objective assertions are
independent of any particular thread’s view and can be placed inside invariants.
This distinction explains why nonatomic points-to assertions in Cosmo are
necessarily subjective: they assert not only that a value exists, but that the
current thread is aware of the corresponding write.

Iris \cite{iris-proofmode} is used for the proof construction. It provides the
general machinery for weakest preconditions. Hoare triples \cite{hoare-logic} in
Cosmo look familiar: a precondition $(P)$ describes the resources required to
execute an expression $(e)$, and the postcondition \(\Phi\) describes the
resources obtained after execution.



\subsection{Conclusion}

This paper introduced Cosmo, a concurrent separation logic that enables formal
reasoning about Multicore OCaml under its relaxed memory model. Unlike
traditional program logics that assume sequential consistency, Cosmo is designed
to reason directly about the realities of modern multicore execution, including
delayed visibility, partial views, and explicit synchronization.

The broader goal of this paper was also to understand how the verification of
concurrent programs evolves as we move closer to real systems. While Cosmo
significantly advances the state of the art by enabling formal reasoning about
Multicore OCaml under a relaxed memory model, it is not the end of the story. As
indicated by the authors, several important directions remain open, including
support for arrays, richer synchronization primitives such as the Domain API,
and full verification of sophisticated lock-free data structures. More
fundamentally, reasoning about programs that intentionally exploit data races on
nonatomic locations remains an open challenge.
