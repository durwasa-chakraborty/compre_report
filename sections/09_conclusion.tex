\section{Conclusion and Research Outlook}

Writing this report has been, in a sense, an exercise in cartography. The
thread running through all of it is deceptively simple: how do we reason about
the correctness of concurrent programs? Linearizability answers this with a
clean semantic contract ; operations appear to take effect instantaneously, at
a single point in time. It restores sequential
intuition to a world of interleaved execution and grants compositionality almost
for free. But as the MCAS case study showed, even stating where an operation
\emph{takes effect} becomes deeply non-trivial once helping and non-local
linearization points enter the picture.

Instrumentation and Rely-Guarantee reasoning were the first attempt to make
this tractable. Rather than quantifying over all concurrent histories, one
reduces linearizability to a safety property, verified locally under
interference summaries. When Zoo entered the picture, that assumption
evaporated. Verifying actual OCaml code means confronting the full complexity of
a real language: physical equality, compiler sharing, and the realization that
correctness can depend not only on algorithmic structure but on guarantees about
memory representation and object identity.

Once sequential consistency is abandoned ; as it must be for any serious
reasoning about modern multicore OCaml ; atomicity can no longer be treated as
a clean global concept. Every correctness argument must now account
simultaneously for algorithm design, release/acquire annotations, and the
guarantees (and gaps) of the underlying memory model. Cosmo makes this
concrete, and the added complexity it introduces feels less like a complication
and more like an honest accounting of what is out there in real world systems.

Reagents approaches the problem from a different angle entirely. Rather than
verifying fine-grained synchronization after the fact, it restructures
concurrency itself around explicit commit boundaries.

Having worked through all of these papers, what I am left with is not
uncertainty about the field, but a clearer sense of where the interesting
problems are. Concurrency verification is not a single discipline: it is a
negotiation between correctness conditions and language semantics. Each of the six works covered in this report sharpens a
different facet of that negotiation. My own research direction is still taking
shape, but the vocabulary and the conceptual tools are now in place. Whatever
problem I eventually commit to, I expect the ingredients for tackling it to
already exist ; distributed across these bodies of work and waiting to be
recombined.
