% ===============================================================================
% Introduction Section
% ===============================================================================
\section{Introduction}
In contemporary computing systems, performance improvements are achieved
primarily through the effective utilization of multicore architectures,
rather than through continued increases in single-core clock frequency. This
architectural shift follows the breakdown of Dennard scaling
\cite{Dennard1974}, under which further increases in transistor density could
no longer be accompanied by proportional reductions in power consumption and
heat dissipation. Consequently, processor design has evolved toward multicore
architectures as the principal mechanism for performance scaling.

As concurrency has become ubiquitous, the central challenge has shifted from
achieving parallelism to reasoning about correctness in its presence. The
nondeterminism inherent in concurrent execution, together with the exponential
growth of possible interleavings on multicore systems, renders conventional
testing methodologies that involves an array of testing suites inadequate.
Establishing correctness therefore requires formal reasoning frameworks capable
of expressing and verifying properties such as atomicity, linearizability, and progress.

This report is organized as follows. We begin by recalling the formal
definition of linearizability~\cite{HerlihyWing1990} in \S2 seminal work by Heerlihy and Wing, the canonical
correctness condition for concurrent objects.

\S3 surveys automated approaches to linearizability, focusing on
the work of Victor Vafeiadis~\cite{Vafeiadis2010}, which demonstrates how
linearization points and interference reasoning can be
mechanized.

We then study Zoo~\cite{zoo2026},\S4, by Allain Cl\'{e}ment and Gabriel Scherer, a framework for verifying concurrent
OCaml5 programs using separation logic. Zoo embeds a core fragment of
OCaml into Rocq and enables machine-checked proofs of fine-grained
concurrent data structures. To understand the practical implications of
such verification, we examine a data structure based on multi-word
compare-and-swap (kCAS)\cite{Guerraoui2013} by Rachid Guerraoui, Alex Kogan, Virendra J. Marathe and Igor Zablotchi, \S5 originally proposed in practical form by
Harris and Fraser~\cite{Harris2002}. Unlike single-word CAS, kCAS
supports atomic updates to multiple memory locations.

Zoo \cite{zoo2026} assumes sequential consistency, whereas real-world Multicore OCaml
operates under a relaxed memory model. To address this discrepancy, we
study Cosmo~\cite{cosmo2020}, \S6, by M\'{e}vel, Glen Jourdan, Jacques-Henri and Fran\c{c}ois Pottier, a concurrent separation logic tailored to
OCamlâ€™s weak memory semantics. Cosmo reconciles high-level reasoning
principles with low-level memory behavior, exposing the additional
subtleties introduced by relaxed memory.

Finally, we consider Reagents~\cite{reagent2012}, \S7, by Aaron Turon, which propose a
transactional abstraction for composing fine-grained concurrent
interactions. Reagents structure lock-free algorithms around explicit
commit boundaries, offering a compositional model that resembles
transactional memory while retaining scalability. Through these successive acts, ie. from specification, to automation, to mechanization, to
memory-model awareness, and ultimately to compositional concurrency
the report explores how modern verification techniques engage with
increasingly expressive concurrent programming paradigms.
