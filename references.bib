@article{Harris2002,
  author  = {Timothy L. Harris and Keir Fraser},
  title   = {A Practical Multi-Word Compare-and-Swap Operation},
  journal = {Distributed Computing},
  volume  = {15},
  number  = {1},
  pages   = {257--271},
  year    = {2002},
  doi     = {10.1007/s00446-002-0085-6}
}

@article{HerlihyWing1990,
  author  = {Maurice P. Herlihy and Jeannette M. Wing},
  title   = {Linearizability: A Correctness Condition for Concurrent Objects},
  journal = {ACM Transactions on Programming Languages and Systems},
  volume  = {12},
  number  = {2},
  pages   = {463--492},
  year    = {1990},
  doi     = {10.1145/78969.78972}
}

@article{Dennard1974,
  author  = {Robert H. Dennard and Fritz H. Gaensslen and Hwa-Nien Yu and
             V. Leo Rideout and Ernest Bassous and Andre R. LeBlanc},
  title   = {Design of Ion-Implanted MOSFETs with Very Small Physical Dimensions},
  journal = {IEEE Journal of Solid-State Circuits},
  volume  = {9},
  number  = {3},
  pages   = {256--268},
  year    = {1974},
  doi     = {10.1109/JSSC.1974.1050511}
}

@inproceedings{Vafeiadis2010,
  author    = {Viktor Vafeiadis},
  title     = {Automatically Proving Linearizability},
  booktitle = {Proceedings of the 22nd International Conference on Computer Aided Verification},
  series    = {Lecture Notes in Computer Science},
  volume    = {6174},
  pages     = {450--464},
  address   = {Edinburgh, Scotland},
  publisher = {Springer},
  year      = {2010},
  doi       = {10.1007/978-3-642-14295-6_40}
}

@inproceedings{Guerraoui2013,
  author    = {Rachid Guerraoui and Alex Kogan and Virendra J. Marathe and Igor Zablotchi},
  title     = {Efficient Multi-Word Compare-and-Swap},
  booktitle = {Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
  address   = {Shenzhen, China},
  pages     = {221--232},
  publisher = {ACM},
  year      = {2013},
  doi       = {10.1145/2442516.2442531}
}

@article{zoo2026,
author = {Allain, Cl\'{e}ment and Scherer, Gabriel},
title = {Zoo: A Framework for the Verification of Concurrent OCaml 5 Programs using Separation Logic},
year = {2026},
issue_date = {January 2026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {POPL},
url = {https://doi.org/10.1145/3776701},
doi = {10.1145/3776701},
abstract = {The release of Ocaml 5, which introduced parallelism in the OCaml runtime, drove the need for safe and efficient concurrent data structures. New libraries like Saturn address this need. This is an opportunity to apply and further state-of-the-art program verification techniques.    We present Zoo, a framework for verifying fine-grained concurrent OCaml 5 algorithms. Following a pragmatic approach, we defined a limited but sufficient fragment of the language to faithfully express these algorithms: ZooLang. We formalized its semantics carefully via a deep embedding in the Rocq proof assistant, uncovering subtle aspects of physical equality. We provide a tool to translate source OCaml programs into ZooLang syntax embedded inside Rocq, where they can be specified and verified using the Iris concurrent separation logic. To illustrate the applicability of Zoo, we verified a subset of the standard library and a collection of fined-grained concurrent data structures from the Saturn and Eio libraries.    In the process, we also extended OCaml to more efficiently express certain concurrent programs.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {59},
numpages = {28},
keywords = {Concurrent Algorithms, Iris, OCaml 5, Rocq, Separation Logic, Verification}
}

@article{cosmo2020,
author = {M\'{e}vel, Glen and Jourdan, Jacques-Henri and Pottier, Fran\c{c}ois},
title = {Cosmo: a concurrent separation logic for multicore OCaml},
year = 2020,
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = 4,
number = {ICFP},
url = {https://doi.org/10.1145/3408978},
doi = {10.1145/3408978},
abstract = {Multicore OCaml extends OCaml with support for shared-memory concurrency. It is equipped with a weak memory model, for which an operational semantics has been published. This begs the question: what reasoning rules can one rely upon while writing or verifying Multicore OCaml code? To answer it, we instantiate Iris, a modern descendant of Concurrent Separation Logic, for Multicore OCaml. This yields a low-level program logic whose reasoning rules expose the details of the memory model. On top of it, we build a higher-level logic, Cosmo, which trades off some expressive power in return for a simple set of reasoning rules that allow accessing nonatomic locations in a data-race-free manner, exploiting the sequentially-consistent behavior of atomic locations, and exploiting the release/acquire behavior of atomic locations. Cosmo allows both low-level reasoning, where the details of the Multicore OCaml memory model are apparent, and high-level reasoning, which is independent of this memory model. We illustrate this claim via a number of case studies: we verify several implementations of locks with respect to a classic, memory-model-independent specification. Thus, a coarse-grained application that uses locks as the sole means of synchronization can be verified in the Concurrent-Separation-Logic fragment of Cosmo, without any knowledge of the weak memory model.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = 96,
numpages = 29,
keywords = {weak memory, separation logic, program verification, concurrency}
}

@inproceedings{reagent2012,
author = {Turon, Aaron},
title = {Reagents: expressing and composing fine-grained concurrency},
year = {2012},
isbn = {9781450312059},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2254064.2254084},
doi = {10.1145/2254064.2254084},
abstract = {Efficient communication and synchronization is crucial for fine grained parallelism. Libraries providing such features, while indispensable, are difficult to write, and often cannot be tailored or composed to meet the needs of specific users. We introduce reagents, a set of combinators for concisely expressing concurrency algorithms. Reagents scale as well as their hand-coded counterparts, while providing the composability existing libraries lack.},
booktitle = {Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157â€“168},
numpages = {12},
keywords = {nonblocking algorithms, monads, fine-grained concurrency, compositional concurrency, arrows},
location = {Beijing, China},
series = {PLDI '12}
}
